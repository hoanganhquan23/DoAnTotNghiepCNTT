{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import path from 'node:path';\nimport { type Options as FdirOptions, fdir } from 'fdir';\nimport picomatch from 'picomatch';\n\nexport interface GlobOptions {\n  absolute?: boolean;\n  cwd?: string;\n  patterns?: string[];\n  ignore?: string[];\n  dot?: boolean;\n  deep?: number;\n  expandDirectories?: boolean;\n  onlyDirectories?: boolean;\n  onlyFiles?: boolean;\n}\n\n// using a directory as entry should match all files inside it\nfunction expandDir(pattern: string) {\n  if (pattern.endsWith('/')) {\n    return `${pattern}**`;\n  }\n  if (pattern.endsWith('\\\\')) {\n    return `${pattern.slice(0, -1)}/**`;\n  }\n  return `${pattern}/**`;\n}\n\nfunction processPatterns({ patterns, ignore = [], expandDirectories = true }: GlobOptions) {\n  const matchPatterns: string[] = [];\n  const ignorePatterns: string[] = ignore.map(p => (!p.endsWith('*') && expandDirectories ? expandDir(p) : p));\n\n  if (!patterns || patterns.length === 0) {\n    return { match: ['**/*'], ignore: ignorePatterns };\n  }\n\n  for (let pattern of patterns) {\n    // using a directory as entry should match all files inside it\n    if (!pattern.endsWith('*') && expandDirectories) {\n      pattern = expandDir(pattern);\n    }\n    if (pattern.startsWith('!') && pattern[1] !== '(') {\n      ignorePatterns.push(pattern.slice(1));\n    } else {\n      matchPatterns.push(pattern);\n    }\n  }\n\n  return { match: matchPatterns, ignore: ignorePatterns };\n}\n\nfunction getFdirBuilder(options: GlobOptions, cwd: string) {\n  const processed = processPatterns(options);\n\n  const matcher = picomatch(processed.match, {\n    dot: options.dot,\n    ignore: processed.ignore\n  });\n\n  const fdirOptions: Partial<FdirOptions> = {\n    // use relative paths in the matcher\n    filters: [options.absolute ? p => matcher(p.slice(cwd.length + 1)) : matcher],\n    relativePaths: true\n  };\n\n  if (options.deep) {\n    fdirOptions.maxDepth = options.deep;\n  }\n\n  if (options.absolute) {\n    fdirOptions.relativePaths = false;\n    fdirOptions.resolvePaths = true;\n    fdirOptions.includeBasePath = true;\n  }\n\n  if (options.onlyDirectories) {\n    fdirOptions.excludeFiles = true;\n    fdirOptions.includeDirs = true;\n  } else if (options.onlyFiles === false) {\n    fdirOptions.includeDirs = true;\n  }\n\n  return new fdir(fdirOptions);\n}\n\nexport function glob(patterns: string[], options?: Omit<GlobOptions, 'patterns'>): Promise<string[]>;\nexport function glob(options: GlobOptions): Promise<string[]>;\nexport async function glob(patternsOrOptions: string[] | GlobOptions, options?: GlobOptions): Promise<string[]> {\n  if (patternsOrOptions && options?.patterns) {\n    throw new Error('Cannot pass patterns as both an argument and an option');\n  }\n\n  const opts = Array.isArray(patternsOrOptions) ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd) : process.cwd();\n\n  return getFdirBuilder(opts, cwd).crawl(cwd).withPromise();\n}\n\nexport function globSync(patterns: string[], options?: Omit<GlobOptions, 'patterns'>): string[];\nexport function globSync(options: GlobOptions): string[];\nexport function globSync(patternsOrOptions: string[] | GlobOptions, options?: GlobOptions): string[] {\n  if (patternsOrOptions && options?.patterns) {\n    throw new Error('Cannot pass patterns as both an argument and an option');\n  }\n\n  const opts = Array.isArray(patternsOrOptions) ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd) : process.cwd();\n\n  return getFdirBuilder(opts, cwd).crawl(cwd).sync();\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAiB;AACjB,kBAAkD;AAClD,uBAAsB;AAetB,SAAS,UAAU,SAAiB;AAClC,MAAI,QAAQ,SAAS,GAAG,GAAG;AACzB,WAAO,GAAG,OAAO;AAAA,EACnB;AACA,MAAI,QAAQ,SAAS,IAAI,GAAG;AAC1B,WAAO,GAAG,QAAQ,MAAM,GAAG,EAAE,CAAC;AAAA,EAChC;AACA,SAAO,GAAG,OAAO;AACnB;AAEA,SAAS,gBAAgB,EAAE,UAAU,SAAS,CAAC,GAAG,oBAAoB,KAAK,GAAgB;AACzF,QAAM,gBAA0B,CAAC;AACjC,QAAM,iBAA2B,OAAO,IAAI,OAAM,CAAC,EAAE,SAAS,GAAG,KAAK,oBAAoB,UAAU,CAAC,IAAI,CAAE;AAE3G,MAAI,CAAC,YAAY,SAAS,WAAW,GAAG;AACtC,WAAO,EAAE,OAAO,CAAC,MAAM,GAAG,QAAQ,eAAe;AAAA,EACnD;AAEA,WAAS,WAAW,UAAU;AAE5B,QAAI,CAAC,QAAQ,SAAS,GAAG,KAAK,mBAAmB;AAC/C,gBAAU,UAAU,OAAO;AAAA,IAC7B;AACA,QAAI,QAAQ,WAAW,GAAG,KAAK,QAAQ,CAAC,MAAM,KAAK;AACjD,qBAAe,KAAK,QAAQ,MAAM,CAAC,CAAC;AAAA,IACtC,OAAO;AACL,oBAAc,KAAK,OAAO;AAAA,IAC5B;AAAA,EACF;AAEA,SAAO,EAAE,OAAO,eAAe,QAAQ,eAAe;AACxD;AAEA,SAAS,eAAe,SAAsB,KAAa;AACzD,QAAM,YAAY,gBAAgB,OAAO;AAEzC,QAAM,cAAU,iBAAAA,SAAU,UAAU,OAAO;AAAA,IACzC,KAAK,QAAQ;AAAA,IACb,QAAQ,UAAU;AAAA,EACpB,CAAC;AAED,QAAM,cAAoC;AAAA;AAAA,IAExC,SAAS,CAAC,QAAQ,WAAW,OAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,CAAC,IAAI,OAAO;AAAA,IAC5E,eAAe;AAAA,EACjB;AAEA,MAAI,QAAQ,MAAM;AAChB,gBAAY,WAAW,QAAQ;AAAA,EACjC;AAEA,MAAI,QAAQ,UAAU;AACpB,gBAAY,gBAAgB;AAC5B,gBAAY,eAAe;AAC3B,gBAAY,kBAAkB;AAAA,EAChC;AAEA,MAAI,QAAQ,iBAAiB;AAC3B,gBAAY,eAAe;AAC3B,gBAAY,cAAc;AAAA,EAC5B,WAAW,QAAQ,cAAc,OAAO;AACtC,gBAAY,cAAc;AAAA,EAC5B;AAEA,SAAO,IAAI,iBAAK,WAAW;AAC7B;AAIA,eAAsB,KAAK,mBAA2C,SAA0C;AAC9G,MAAI,sBAAqB,mCAAS,WAAU;AAC1C,UAAM,IAAI,MAAM,wDAAwD;AAAA,EAC1E;AAEA,QAAM,OAAO,MAAM,QAAQ,iBAAiB,IAAI,EAAE,GAAG,SAAS,UAAU,kBAAkB,IAAI;AAC9F,QAAM,MAAM,KAAK,MAAM,iBAAAC,QAAK,QAAQ,KAAK,GAAG,IAAI,QAAQ,IAAI;AAE5D,SAAO,eAAe,MAAM,GAAG,EAAE,MAAM,GAAG,EAAE,YAAY;AAC1D;AAIO,SAAS,SAAS,mBAA2C,SAAiC;AACnG,MAAI,sBAAqB,mCAAS,WAAU;AAC1C,UAAM,IAAI,MAAM,wDAAwD;AAAA,EAC1E;AAEA,QAAM,OAAO,MAAM,QAAQ,iBAAiB,IAAI,EAAE,GAAG,SAAS,UAAU,kBAAkB,IAAI;AAC9F,QAAM,MAAM,KAAK,MAAM,iBAAAA,QAAK,QAAQ,KAAK,GAAG,IAAI,QAAQ,IAAI;AAE5D,SAAO,eAAe,MAAM,GAAG,EAAE,MAAM,GAAG,EAAE,KAAK;AACnD;","names":["picomatch","path"]}